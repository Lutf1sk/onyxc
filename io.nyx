import "unix.nyx";

let cstr :: u8*(u8[] path, u8[] out) {
	if path.count >= out.count {
		return null;
	}

	for usz i..path.count {
		out[i] = path[i];
	}
	out[path.count] = 0;
	return out.data;
}
let cstrlen :: usz(u8* str) {
	u8* it = str;
	while *it {
		++it;
	}
	return usz:(it - str);
}

let file_openw :: u8(isz* fdp, u8[] path) {
	u8[PATH_MAX] path_nt;
	cstr(path, path_nt);
	*fdp = open(path_nt.data, O_WRONLY|O_TRUNC|O_CREAT, S_IRUSR|S_IWUSR);
	return *fdp < 0;
}

let file_openr :: u8(isz* fdp, u8[] path) {
	u8[PATH_MAX] path_nt;
	cstr(path, path_nt);
	*fdp = open(path_nt.data, O_RDONLY, 0);
	return *fdp < 0;
}

let file_close :: void(isz fd) {
	close(fd);
}

let file_write :: void(isz fd, u8[] data) {
	write(fd, data);
}

let file_read :: usz(isz fd, u8[] data) {
	return read(fd, data);
}

let print :: isz(u8[] str) {
	return write(1, str);
}

let print_i64 :: usz(i64 n) {
	if (n < 0) {
		print("-");
		n = -n;
	}

	u8[32] str;
	u8* end = str.data + str.count, it = end - 1;

	while n >= 10 {
		*it-- = n % 10 + '0';
		n /= 10;
	}
	*it = n + '0';

	u8[] view = it[0..usz:(end - it)];
	print(view);
	return view.count;
}

let print_h64 :: usz(u64 n) {
	u8[16] hex_conv_tab :: "0123456789ABCDEF";

	u8[16] str;
	u8* end = str.data + str.count, it = end - 1;

	while n > 0x0F {
		*it-- = hex_conv_tab[n & 0x0F];
		n >>= 4u;
	}
	*it = hex_conv_tab[n];

	u8[] view = it[0..usz:(end - it)];
	print(view);
	return view.count;
}

// time.nyx

let time_nsec :: u64() {
	timespec_t ts;
	clock_gettime(CLOCK_MONOTONIC, &ts);
	return ts.tv_sec * 1000000000 + ts.tv_nsec;
}

let time_usec :: u64() {
	return time_nsec() / 1000;
}

let time_msec :: u64() {
	return time_nsec() / 1000000;
}

// bitmath.nyx

let is_pow2 :: u8(usz n) {
	return ~(n & (n - 1));
}

let pad :: usz(usz val, usz align) {
	usz align_mask = align - 1;
	return ((val & align_mask) ^ align_mask) + 1;
}

let alignf :: usz(usz val, usz align) {
	usz align_mask = align - 1;
	return (val + align_mask) & ~align_mask;
}

let alignb :: usz(usz val, usz align) {
	return val & ~(align - 1);
}

// mem.nyx

let mcopy :: void(void* dst, void* src, usz bytes) {
	u8* dst_it = dst;
	u8* src_it = src;

	while bytes-- {
		*dst_it++ = *src_it++;
	}
}

let mset8 :: void(void* dst, u8 v, usz bytes) {
	u8* it = dst;
	while bytes-- {
		*it++ = v;
	}
}

let vmem_alloc :: void*(usz size) {
	isz addr = isz:mmap(0, size, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
	if (addr < 0) {
		return null;
	}
	return void*:addr;
}

let vmem_free :: void(void* mem, usz size) {
	munmap(usz:mem, size);
}

usz VMEM_BLOCK_SIZE :: 4096;
usz ALLOC_DEFAULT_ALIGN :: 16;

def Allocator :: struct {
	void*(void*, usz) alloc;
	void*(void*, void*, usz) realloc;
	void(void*, void*) free;
	usz(void*, void*) size;
	void* usr;
}

def Arena :: struct {
	void* base;
	usz size;
	void* top;
	Allocator interf;
}

let amalloc :: void*(Arena* arena, usz size) {
	void* start = void*:alignf(usz:arena.top, ALLOC_DEFAULT_ALIGN);
	void* new_top = start + ALLOC_DEFAULT_ALIGN + size;
	void* top_max = arena.base + arena.size;

	if new_top > top_max {
		return null;
	}
	*usz*:new_top = size;
	arena.top = new_top;
	return start + ALLOC_DEFAULT_ALIGN;
}

let amrealloc :: void*(Arena* arena, void* ptr, usz new_size) {
	usz old_size = *usz*:(ptr - ALLOC_DEFAULT_ALIGN);

	if arena.top == ptr + old_size {
		void* top_max = arena.base + arena.size;
		*usz*:(ptr - ALLOC_DEFAULT_ALIGN) = new_size;
		if ptr + new_size > top_max {
			return null;
		}
		return ptr;
	}

	void* new_ptr = amalloc(arena, new_size);
	if !new_ptr {
		return null;
	}
	mcopy(new_ptr, ptr, old_size);
	return new_ptr;
}

let amfree :: void(Arena* arena, void* ptr) {
	usz old_size = *usz*:(ptr - ALLOC_DEFAULT_ALIGN);
	if arena.top == ptr + old_size {
		arena.top = ptr - ALLOC_DEFAULT_ALIGN;
	}
}

let amsize :: usz(Arena* arena, void* ptr) {
	return *usz*:(ptr - ALLOC_DEFAULT_ALIGN);
}

let amsave :: void*(Arena* arena) {
	return arena.top;
}

let amrestore :: void(Arena* arena, void* old) {
	arena.top = old;
}

let amcreate :: Arena*(usz size) {
	if size < usz:sizeof(Arena) {
		return null;
	}

	size = alignf(size, VMEM_BLOCK_SIZE);

	void* base = vmem_alloc(size);
	if !base {
		return null;
	}

	Arena* arena = base;
	arena.base = base;
	arena.size = size;
	arena.top = base;
	arena.interf.alloc = void*(void*, usz): amalloc;
	arena.interf.realloc = void*(void*, void*, usz): amrealloc;
	arena.interf.free = void(void*, void*): amfree;
	arena.interf.size = usz(void*, void*): amsize;
	arena.interf.usr = arena;
	amalloc(arena, sizeof(Arena)); // Reserve an area covering the header
	return arena;
}

let amdestroy :: void(Arena* arena) {
	vmem_free(arena.base, arena.size);
}

// str.nyx


let stou :: u8(u8[] str, u64* out) {
	u8* it = str.data;
	u8* end = it + str.count;

	if it == end {
		return 1;
	}

	i64 v = 0;
	while it < end {
		u8 c = *it++;

		if c > '9' || c < '0' {
			return 1;
		}

		v *= 10;
		v += c - '0';
	}

	*out = v;
	return 0;
}

let stoi :: u8(u8[] str, i64* out) {
	u8* it = str.data;
	u8* end = it + str.count;

	if it == end {
		return 1;
	}

	u8 sign = 0;
	if *it == '-' {
		sign = 1;
		if it++ == end {
			return 1;
		}
	}

	i64 v = 0;
	while it < end {
		u8 c = *it++;
		if c > '9' || c < '0' {
			return 1;
		}

		v *= 10;
		v += c - '0';
	}

	if sign {
		v = -v;
	}

	*out = v;
	return 0;
}

let is_digit :: u8(u8 c) {
	return c >= '0' && c <= '9';
}

let streq :: u8(u8[] s1, u8[] s2) {
	if s1.count != s2.count {
		return 0;
	}

	for usz i..s1.count {
		if s1[i] != s2[i] {
			return 0;
		}
	}
	return 1;
}

