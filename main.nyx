import "io.nyx", "elf.nyx", "dns.nyx";


let hton16 :: u16(u16 v) {
	return (v >> 8u) | ((v & 0xFF) << 8u);
}

let hton32 :: u32(u32 v) {
	return	((v & 0x000000FF) << 24u) |
			((v & 0x0000FF00) << 8u) |
			((v & 0x00FF0000) >> 8u) |
			((v & 0xFF000000) >> 24u);
}

// let hton64 :: u64(u64 v) {
// 	return	((v & 0x00000000000000FF) << 56u) |
// 			((v & 0x000000000000FF00) << 40u) |
// 			((v & 0x0000000000FF0000) << 24u) |
// 			((v & 0x00000000FF000000) << 8u) |
// 			((v & 0x000000FF00000000) >> 8u) |
// 			((v & 0x0000FF0000000000) >> 24u) |
// 			((v & 0x00FF000000000000) >> 40u) |
// 			((v & 0xFF00000000000000) >> 56u);
// }

let ipv4_parse_addr :: u8(u8[] str, sockaddr_in_t* out) {
	u8[][5] nums;
	usz j = 0;

	u8* num_start = str.data;
	for usz i..str.count {
		u8 c = str[i];
		if c == '.' {
			if j >= 3u {
				return 1;
			}
			nums[j++] = num_start[0..usz:(i - (num_start - str.data))];
			num_start = str.data + i + 1;
		}
		if c == ':' {
			if j != 3u {
				return 1;
			}
			nums[j++] = num_start[0..usz:(i - (num_start - str.data))];
			num_start = str.data + i + 1;
		}
	}
	if j < 3u {
		return 1;
	}
	nums[j] = num_start[0..usz:(str.count - (num_start - str.data))];

	u32 addr = 0;
	for usz i..4 {
		u64 v;
		if stou(nums[i], &v) || v > 0xFF {
			return 1;
		}
		addr |= v << i * 8;
	}

	if j == 4u {
		u64 v;
		if stou(nums[4], &v) || v > 0xFFFF {
			return 1;
		}
		out.sin_port = hton16(v);
	}

	out.sin_addr = addr;
	return 0;
}

let recv :: isz(isz sock, void[] buf) {
	void* it = buf.data, end = it + buf.count;
	while it < end {
		isz res = sock->read(it[0..usz:(end - it)]);
		if res <= 0 {
			return res;
		}

		it += res;
	}
	return buf.count;
}

let dns_encode_name :: isz(u8[] domain, u8[] out) {
	u8* q_it = out.data, q_max = q_it + out.count;
	u8* substr = domain.data;
	for usz i..domain.count {
		if domain[i] == '.' {
			usz substr_len = i - usz:(substr - domain.data);
			u8* q_it_next = q_it + substr_len + 1;
			if !substr_len || substr_len > 63u || q_it_next >= q_max {
				return -1;
			}
			*q_it++ = substr_len;
			for usz j..substr_len {
				*q_it++ = substr[j];
			}

			q_it = q_it_next;
			substr = domain.data + i + 1;
		}
	}

	usz substr_len = domain.count - usz:(substr - domain.data);
	u8* q_it_next = q_it + substr_len + 2;
	if !substr_len || substr_len > 63u || q_it_next >= q_max {
		return -1;
	}
	*q_it++ = substr_len;
	for usz j..substr_len {
		*q_it++ = substr[j];
	}

	*q_it++ = 0;
	return usz:(q_it - out.data);
}

let ipv4_dnslookup :: u8(u8[] dns_host, u8[] domain, sockaddr_in_t* out) {
	sockaddr_in_t saddr;
	mset8(&saddr, 0, sizeof(sockaddr_in_t));
	saddr.sin_family = AF_INET;
	saddr.sin_port = hton16(53);

	if ipv4_parse_addr(dns_host, &saddr) {
		return 1;
	}

	isz sock = socket(AF_INET, SOCK_STREAM, 0);
	if sock < 0 {
		return 1;
	}

	if sock->connect(void*:&saddr, sizeof(sockaddr_in_t)) < 0 {
		sock->close();
		return 1;
	}

	DNS_Header dh;
	mset8(&dh, 0, sizeof(DNS_Header));
	dh.flags = hton16(DNSH_QUERY | DNSH_STANDARD | DNSH_RD);
	dh.qdcount = hton16(1);

	DNS_Question dq;
	dq.qtype = hton16(DNST_A);
	dq.qclass = hton16(DNSC_IN);

	u8[256] question;
	isz qlen = dns_encode_name(domain, question);
	if qlen < 0 {
		sock->close();
		return 1;
	}

	u16 msglen = hton16(sizeof(DNS_Header) + qlen + sizeof(DNS_Question));
	sock->write((&msglen)[0..1]);
	sock->write((&dh)[0..1]);
	sock->write(question[0..qlen]);
	sock->write((&dq)[0..1]);

	// Receive message length
	if sock->recv((&msglen)[0..1]) <= 0 {
		sock->close();
		return 1;
	}
	msglen = hton16(msglen);

	// Receive message body
	u8[4096] buf;
	if sock->recv(buf[0..msglen]) <= 0 || msglen < u32:sizeof(DNS_Header) {
		sock->close();
		return 1;
	}

	sock->close();

	DNS_Header* rh = void*:buf.data;
	rh.flags = hton16(rh.flags);
	rh.qdcount = hton16(rh.qdcount);
	rh.ancount = hton16(rh.ancount);
	rh.nscount = hton16(rh.nscount);
	rh.arcount = hton16(rh.arcount);

	u16 rcode = rh.flags & DNSH_RCODE_MASK;
	if rcode != DNSH_NO_ERROR {
		return 1;
	}

	void* section_start = buf.data + sizeof(DNS_Header);
	u8* it = section_start;

	// TODO: Prevent out-of-bounds writes

	for usz i..rh.qdcount {
		while *it { it++; } // QNAME
		it += sizeof(DNS_Question);
	}

	for usz i..rh.ancount {
		while *it { it++; } // NAME
		let rr = DNS_RsrcRecord*:it;
		rr.type = hton16(rr.type);
		rr.class = hton16(rr.class);
		rr.ttl = hton16(rr.ttl);
		rr.rdlen = hton16(rr.rdlen);

		it += sizeof(DNS_RsrcRecord);

		if rr.type == DNST_A && rr.class == DNSC_IN {
			out.sin_addr = *u32*:it;
			return 0;
		}

		it += rr.rdlen; // RDATA
	}

	return 1;
}

// https://refspecs.linuxfoundation.org/elf/gabi4+/ch5.dynamic.html

let elf_verify_magic :: u8(ELF64_FileHeader* fh) {
	for usz i..fh.magic.count {
		if fh.magic[i] != ELFMAGIC[i] {
			return 0;
		}
	}
	return 1;
}

def DynLibList :: struct {
	void* lib;
	void* next;
}

def DynLibrary :: struct {
	u8[] name;
	u8* img_base;
	u8* data;
	ELF64_FileHeader* fh;
	u8* strtab;
	u8* strtab_sym;
	ELF64_Sym[] syms;

	usz ref_count;
	void* deps;
}

let elf_getsh :: ELF64_SectHeader*(ELF64_FileHeader* fh, usz i) {
	return ELF64_SectHeader*:fh + fh.sh_offs + fh.sh_size * i;
}

let elf_getph :: ELF64_ProgHeader*(ELF64_FileHeader* fh, usz i) {
	return ELF64_ProgHeader*:fh + fh.ph_offs + fh.ph_size * i;
}

let elf_getstr :: u8[](u8* strtab, usz offs) {
	u8* str = strtab + offs;
	return str[0..cstrlen(str)];
}

let elf_img_size :: usz(ELF64_FileHeader* fh) {
	usz max = 0;
	for usz i..fh.sh_count {
		let sh = elf_getsh(fh, i);
		usz top = sh.addr + sh.size;
		if (sh.type == ELFSH_PROGBITS || sh.type == ELFSH_NOBITS) && top > max {
			max = top;
		}
	}
	return max;
}

let elf_map_sections :: void(ELF64_FileHeader* fh, u8* img_base) {
	for usz i..fh.sh_count {
		let sh = elf_getsh(fh, i);
		if sh.type == ELFSH_PROGBITS {
			mcopy(img_base + sh.addr, fh + sh.offs, sh.size);
		}
		if sh.type == ELFSH_NOBITS {
			mset8(img_base + sh.addr, 0, sh.size);
		}
	}
}

let elf_find_symdef :: ELF64_Sym*(DynLibrary* lib, u8[] name) {
	ELF64_Sym* weak = null;

	for usz i..lib.syms.count {
		ELF64_Sym* sym = &lib.syms[i];
		u8 binding = sym.info & ELFSYM_BIND_MASK;
		u8[] symname = elf_getstr(lib.strtab_sym, sym.name);
		if streq(name, symname) {
			if binding == ELFSYM_GLOBAL || binding == ELFSYM_LOCAL {
				return sym;
			}
			if (binding == ELFSYM_WEAK) {
				weak = sym;
			}
		}
	}

	DynLibList* lit = lib.deps;
	while lit {
		DynLibrary* lib = lit.lib;

		for usz i..lib.syms.count {
			ELF64_Sym* sym = &lib.syms[i];
			u8 binding = sym.info & ELFSYM_BIND_MASK;
			if binding == ELFSYM_GLOBAL {
				u8[] symname = elf_getstr(lib.strtab_sym, sym.name);
				if streq(name, symname) {
					return sym;
				}
			}
		}
		lit = lit.next;
	}

	return weak;
}

Pool* dlib_pool = null;
Pool* dlib_list_pool = null;

void* dlib_list_head = null;

let list_find_dlib :: DynLibrary*(void* head, u8[] name) {
	DynLibList* it = head;
	while it {
		if streq((DynLibrary*:it.lib).name, name) {
			return it.lib;
		}
		it = it.next;
	}
	return null;
}

let list_insert_dlib :: void(void** head, DynLibrary* lib) {
	DynLibList* new_entry = pmalloc(dlib_list_pool);
	new_entry.lib = lib;
	new_entry.next = *head;
	*head = new_entry;
}

DynLibrary*(u8[], Allocator*) dlopen_p = null;

let dlopen :: DynLibrary*(u8[] libname, Allocator* alc) {
	if !dlib_pool {
		dlib_pool = pmcreate(4096, sizeof(DynLibrary));
		dlib_list_pool = pmcreate(8192, sizeof(DynLibrary));
		if !dlib_pool || !dlib_list_pool {
			print("failed to map pool\n");
			return null;
		}
	}

	DynLibrary* lib = list_find_dlib(dlib_list_head, libname);
	if lib {
		return lib;
	}

	u8[] libpath_pfx :: "/usr/lib/";
	usz libpath_len = libpath_pfx.count + libname.count;
	u8[] libpath = alc.alloc(alc.usr, libpath_len)[0..libpath_len];
	if !libpath.data {
		print("allocation failed\n");
		return null;
	}
	mcopy(libpath.data, libpath_pfx.data, libpath_pfx.count);
	mcopy(libpath.data + libpath_pfx.count, libname.data, libname.count);

	isz fd;
	if &fd->file_openr(libpath) {
		print("failed to open file\n");
		return null;
	}
	alc.free(alc.usr, libpath.data);

	stat_t st;
	fd->fstat(&st);

	u8* elf_data = alc.alloc(alc.usr, st.st_size);
	if !elf_data {
		print("allocation failed\n");
		return null;
	}
	fd->read(elf_data[0..st.st_size]);
	fd->close();

	let fh = ELF64_FileHeader*:elf_data;
	if !elf_verify_magic(fh) {
		print("ELF magic invalid\n");
		alc.free(alc.usr, elf_data);
		return null;
	}

	u8* strtab = elf_data + elf_getsh(fh, fh.strtab_index).offs;

	ELF64_Sym[] syms = null[0..0];

	for usz i..fh.sh_count {
		let sh = elf_getsh(fh, i);
		u8[] name = elf_getstr(strtab, sh.name);

		if sh.type == ELFSH_DYNSYM {
			syms = (ELF64_Sym*:elf_data + sh.offs)[0..sh.size/sizeof(ELF64_Sym)];
		}
	}

	u8[] interp = null[0..0];
	ELF64_Dyn* dyn_start = null;

	for usz i..fh.ph_count {
		let ph = elf_getph(fh, i);

		if ph.type == ELFPH_INTERP {
			interp = (elf_data + ph.offs)[0..ph.mem_size];
		}
		if ph.type == ELFPH_DYNAMIC {
			dyn_start = ELF64_Dyn*:elf_data + ph.offs;
		}
	}

	if !dyn_start {
		print("no dynamic section found\n");
		alc.free(alc.usr, elf_data);
		return null;
	}

	u8* base = alc.alloc(alc.usr, elf_img_size(fh));
	if !base {
		print("allocation failed\n");
		alc.free(alc.usr, elf_data);
		return null;
	}
	elf_map_sections(fh, base);

	u8* strtab_sym = null;
	ELF64_RelAdd* rela_ptr = null;
	usz relasz = 0, relaent = 0;

	void() init = null;
	void*[] initarr = null[0..0];

	isz soname_offs = -1;

	ELF64_Dyn* dyn = dyn_start;
	while dyn && dyn.type != ELFDYN_NULL {
		if dyn.type == ELFDYN_STRTAB {
			strtab_sym = elf_data + dyn.val;
		}
		if dyn.type == ELFDYN_RELA {
			rela_ptr = ELF64_RelAdd*:(elf_data + dyn.val);
		}
		if dyn.type == ELFDYN_RELASZ {
			relasz = dyn.val;
		}
		if dyn.type == ELFDYN_RELAENT {
			relaent = dyn.val;
		}
		if dyn.type == ELFDYN_INIT {
			init = void*:base + dyn.val;
		}
		if dyn.type == ELFDYN_INIT_ARRAY {
			initarr.data = void*:elf_data + dyn.val;
		}
		if dyn.type == ELFDYN_INIT_ARRAYSZ {
			initarr.count = dyn.val / sizeof(void*);
		}
		if dyn.type == ELFDYN_SONAME {
			soname_offs = dyn.val;
		}
		dyn += sizeof(ELF64_Dyn);
	}

	u8[] soname = null[0..0];
	if soname_offs >= 0 {
		soname = elf_getstr(strtab_sym, soname_offs);
	}
	else {
		soname = malloc_init(alc, libname);
	}

	print("SONAME: ");
	print(soname);
	print("\n");

	lib = pmalloc(dlib_pool);
	lib.name = soname;
	lib.img_base = base;
	lib.data = elf_data;
	lib.fh = fh;
	lib.strtab = strtab;
	lib.strtab_sym = strtab_sym;
	lib.syms = syms;
	lib.ref_count = 1;
	lib.deps = null;

	dyn = dyn_start;
	while dyn && dyn.type != ELFDYN_NULL {
		if dyn.type == ELFDYN_NEEDED {
			DynLibrary* dep = dlopen_p(elf_getstr(strtab_sym, dyn.val), alc);
			if !dep {
				print("Failed to load dependency\n");
			}
			list_insert_dlib(&lib.deps, dep);
		}
		dyn += sizeof(ELF64_Dyn);
	}

	list_insert_dlib(&dlib_list_head, lib);

	ELF64_RelAdd* rela = rela_ptr;
	usz rela_count = relasz / relaent;

	for usz i..rela_count {
		u32 reltype = rela.info & ELFREL64_TYPE_MASK;
		u32 relsym = rela.info >> ELFREL64_SYM_SHIFT;

		u8 unkn = 1;

		void* patch_ptr = base + rela.offs;

		if reltype == ELFREL_X64_NONE {
			unkn = 0;
		}
		if reltype == ELFREL_X64_64 {
			unkn = 0;
			u8[] symname = elf_getstr(strtab_sym, syms[relsym].name);
			ELF64_Sym* sym = elf_find_symdef(lib, symname);
			if (!sym) {
				print("undefined reference to ");
				print(symname);
				print("\n");
			}
			*u64*:patch_ptr = usz:base + sym.val + rela.addend;
		}
		if reltype == ELFREL_X64_RELATIVE {
			unkn = 0;
			*u64*:patch_ptr = usz:base + rela.addend;
		}
		if reltype == ELFREL_X64_GLOB_DAT {
			unkn = 0;
			u8[] symname = elf_getstr(strtab_sym, syms[relsym].name);
			ELF64_Sym* sym = elf_find_symdef(lib, symname);
			if (!sym) {
				print("undefined reference to ");
				print(symname);
				print("\n");
			}
			else {
				*u64*:patch_ptr = usz:base + sym.val;
			}
		}
		if reltype == ELFREL_X64_IRELATIVE {
			unkn = 0;
		}
		if reltype == ELFREL_X64_TPOFF64 {
			unkn = 0;
			u8[] symname = elf_getstr(strtab_sym, syms[relsym].name);
			ELF64_Sym* sym = elf_find_symdef(lib, symname);
			if (!sym) {
				print("undefined reference to ");
				print(symname);
				print("\n");
			}
		}

		if unkn {
			print("Unknown relocation type: ");
			print_i64(reltype);
			print("\n");
		}

		rela += relaent;
	}

// 	for usz i..syms.count {
// 		print("SYM ");
// 		print_i64(i);
// 		print(" 0x");
// 		print_h64(syms[i].info);
// 		print(" '");
// 		print(elf_getstr(strtab_sym, syms[i].name));
// 		print("'\n");
// 	}

// 	if init {
// 		init();
// 	}

// 	if initarr.data {
// 		for usz i..initarr.count {
// 			void() func = initarr[i] + void*:elf_data;
// 			func();
// 		}
// 	}

	return lib;
}

let dlsym :: void*(DynLibrary* lib, u8[] name) {
	for usz i..lib.syms.count {
		if streq(name, elf_getstr(lib.strtab_sym, lib.syms[i].name)) {
			return lib.img_base + lib.syms[i].val;
		}
	}
	return null;
}

let main :: u64() {
	dlopen_p = dlopen;

	Arena* arena = amcreate(32M);

// 	DynLibrary* rtld_lib = dlopen("ld-linux-x86-64.so.2", &arena.interf);
// 	if !rtld_lib {
// 		print("failed to load RTLD\n");
// 	}

	DynLibrary* libc = dlopen("libvulkan.so", &arena.interf);
	if !libc {
		print("failed to load library\n");
	}

// 	void*(usz) func_hnd = dlsym(libc, "malloc");
// 	if !func_hnd {
// 		print("Failed to load symbol\n");
// 	}

// 	print("func: 0x");
// 	print_h64(usz:func_hnd(0));
// 	print("\n");

	exit(69);

	isz sock = socket(AF_INET, SOCK_STREAM, 0);
	if sock < 0 {
		print("socket creation failed\n");
	}

	sockaddr_in_t saddr;
	mset8(&saddr, 0, sizeof(sockaddr_in_t));
	saddr.sin_family = AF_INET;
	saddr.sin_port = hton16(80);

	if ipv4_dnslookup("9.9.9.9", "lutfisk.net", &saddr) {
		print("failed to resolve host\n");
	}

	if connect(sock, void*:&saddr, sizeof(sockaddr_in_t)) < 0 {
		print("connection failed\n");
	}

	write(sock, "GET / HTTP/1.1\r\nHost: lutfisk.net\r\nAccept: */*\r\nUpgrade-Insecure-Requests: 0\r\nConnection: close\r\n\r\n");

	u8[512] buf;
	isz bytes;
	while bytes = read(sock, buf) {
		print(buf[0..bytes]);
	}

	exit(0);
}

