import "std/io.nyx", "std/mem.nyx", "std/dynlib.nyx";

def TK :: enum u32 {
	EOF,
	IDENT,
	STR, CHAR,
	INT, FLOAT,

	DOT, DDOT,
	COLON, DCOLON,
	PLUS, DPLUS, PLUSEQ,
	MINUS, DMINUS, MINUSEQ, MINUSGREATER,
	ASTERISK, ASTERISKEQ,
	SLASH, SLASHEQ,
	CARET, DCARET, CARETEQ,
	AMPERSAND, DAMPERSAND, AMPERSANDEQ,
	PIPE, DPIPE, PIPEEQ,
	EQUAL, DEQUAL,
	LESSER, DLESSER, LESSEREQ, DLESSEREQ,
	GREATER, DGREATER, GREATEREQ, DGREATEREQ,

	LPAREN, RPAREN,
	LBRACKET, RBRACKET,
	LBRACE, RBRACE,

	KW_BREAK, KW_CONTINUE,
	KW_FOR, KW_WHILE,
	KW_SWITCH, KW_CASE,
	KW_IF, KW_ELIF, KW_ELSE,
	KW_LET,
	KW_DEF, KW_STRUCT, KW_ENUM, KW_EXPLICIT, KW_IMPLICIT,
	KW_RETURN,
	KW_IMPORT, KW_INCLUDE,
	KW_SIZEOF, KW_ALIGNOF,
	KW_NULL,

	KW_SYSCALL,
};

def Token :: struct {
	u32 type;
	u32 file;
	u8[] str;
}

let tokenize :: Token[](u8[] data) {

}

let main :: u64() {
	dlopen_p = dlopen;
	Arena* arena = amcreate(64M);

	u8[] in_path = "main.nyx";

	isz in_f;
	if fopenr(&in_f, in_path) {
		print("Failed to open '");
		print(in_path);
		print("'\n");
		exit(1);
	}

	stat_t st;
	if fstat(in_f, &st) < 0 {
		print("fstat() failed\n");
		exit(1);
	}

	u8[] in_data = amalloc(arena, 0)[0..st.st_size];
	if read(in_f, in_data) != in_data.count {
		print("read() failed\n");
		exit(1);
	}

	print(in_data);

	Token[] tks = tokenize(in_data);

	exit(0);
}

