import "std/io.nyx", "std/mem.nyx", "std/dynlib.nyx";

def TK :: enum u32 {
	EOF,
	IDENT,
	STR, CHAR,
	INT, FLOAT,

	DOT, DDOT,
	COLON, DCOLON,
	PLUS, DPLUS, PLUSEQ,
	MINUS, DMINUS, MINUSEQ, MINUSGREATER,
	ASTERISK, ASTERISKEQ,
	SLASH, SLASHEQ,
	CARET, DCARET, CARETEQ,
	AMPERSAND, DAMPERSAND, AMPERSANDEQ,
	PIPE, DPIPE, PIPEEQ,
	EQUAL, DEQUAL,
	LESSER, DLESSER, LESSEREQ, DLESSEREQ,
	GREATER, DGREATER, GREATEREQ, DGREATEREQ,

	LPAREN, RPAREN,
	LBRACKET, RBRACKET,
	LBRACE, RBRACE,

	KW_BREAK, KW_CONTINUE,
	KW_FOR, KW_WHILE,
	KW_SWITCH, KW_CASE,
	KW_IF, KW_ELIF, KW_ELSE,
	KW_LET,
	KW_DEF, KW_STRUCT, KW_ENUM, KW_EXPLICIT, KW_IMPLICIT,
	KW_RETURN,
	KW_IMPORT, KW_INCLUDE,
	KW_SIZEOF, KW_ALIGNOF,
	KW_NULL,

	KW_SYSCALL,
};

def Token :: struct {
	u32 type;
	u32 file;
	u8[] str;
}

def CTYPE :: enum u8 {
	NONE	:: 0x00,
	ALPHA	:: 0x01,
	DIGIT	:: 0x02,
	SPACE	:: 0x04,
};

CTYPE[256] ctype_tab :: {
	NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,			// 0..7
	NONE, SPACE, SPACE, SPACE, NONE, SPACE, NONE, NONE,		// 8..15
	NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,			// 16..23
	NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,			// 24..31

	SPACE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,		// 32..39
	NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,			// 40..47
	DIGIT, DIGIT, DIGIT, DIGIT, DIGIT, DIGIT, DIGIT, DIGIT,	// 48..55
	DIGIT, DIGIT, NONE, NONE, NONE, NONE, NONE, NONE,		// 56..63

	NONE, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA,	// 64..71
	ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA,	// 72..79
	ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA,	// 80..87
	ALPHA, ALPHA, ALPHA, NONE, NONE, NONE, NONE, NONE,		// 88..95

	NONE, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA,	// 96..103
	ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA,	// 104..111
	ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA,	// 112..119
	ALPHA, ALPHA, ALPHA, NONE, NONE, NONE, NONE, NONE,		// 120..127
};

let is_alpha8 :: u8(u8 c) {
	return ctype_tab[c] & ALPHA;
}

let is_alpha32 :: u8(u32 c) {
	return c < ctype_tab.count && ctype_tab[c] & ALPHA;
}

let is_digit8 :: u8(u8 c) {
	return ctype_tab[c] & DIGIT;
}

let is_digit32 :: u8(u32 c) {
	return c < ctype_tab.count && ctype_tab[c] & DIGIT;
}

let is_space8 :: u8(u8 c) {
	return ctype_tab[c] & SPACE;
}

let is_space32 :: u8(u32 c) {
	return c < ctype_tab.count && ctype_tab[c] & SPACE;
}

let tokenize :: Token[](u8[] data) {
	u8* it = data.data, end = data.data + data.count;

	while it < end {
		u8* tk_start = it;

		switch ctype_tab[*it]
		case ALPHA {
			while it < end && (is_alpha8(*it) || is_digit8(*it) || *it == '_') {
				void:++it;
			}
			goto emit;
		},
		case DIGIT {
			while it < end && is_digit8(*it) {
				++it;
			}
			goto emit;
		},
		case SPACE {
			++it;
			continue;
		},
		default {};

		switch *it++
		default {
			print("Unhandled symbol '");
			print(tk_start[0..usz:(it - tk_start)]);
			print("'\n");
			continue;
		};
	emit:
		print("[");
		print(tk_start[0..usz:(it - tk_start)]);
		print("]\n");
	}
}

let main :: u64() {
	dlopen_p = dlopen;
	Arena* arena = amcreate(64M);

	u8[] in_path = "main.nyx";

	isz in_f;
	if fopenr(&in_f, in_path) {
		print("Failed to open '");
		print(in_path);
		print("'\n");
		goto err0;
	}

	stat_t st;
	if fstat(in_f, &st) < 0 {
		print("fstat() failed\n");
		goto err1;
	}

	u8* in_data = amalloc(arena, st.st_size + 2);
	in_data[0] = 0;
	in_data[st.st_size] = 0;
	u8[] invw = (in_data + 1)[0..st.st_size];
	if fread(in_f, invw) != st.st_size {
		print("read() failed\n");
		goto err1;
	}
	fclose(in_f);

// 	print(invw);
	Token[] tks = tokenize(invw);

	amdestroy(arena);
	exit(0);

err1:	fclose(in_f);
err0:	amdestroy(arena);
		exit(1);
}

