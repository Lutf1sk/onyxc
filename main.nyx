import "io.nyx", "elf.nyx";

let elf_verify_magic :: u8(ELF64_FileHeader* fh) {
	for usz i..fh.magic.count {
		if fh.magic[i] != ELFMAGIC[i] {
			return 0;
		}
	}
	return 1;
}

let elf_getsh :: ELF64_SectHeader*(ELF64_FileHeader* fh, usz i) {
	return ELF64_SectHeader*:(usz:fh + fh.sh_offs + fh.sh_size * i);
}

let elf_getph :: ELF64_ProgHeader*(ELF64_FileHeader* fh, usz i) {
	return ELF64_ProgHeader*:(usz:fh + fh.ph_offs + fh.ph_size * i);
}

let dlopen :: ELF64_FileHeader*(u8[] libname) {
	isz fd;
	if &fd->file_openr(libname) {
		print("Failed to open file\n");
		return null;
	}

	stat_t st;
	fd->fstat(&st);

	u8* elf_data = malloc(st.st_size);
	fd->read(elf_data[0..st.st_size]);
	fd->close();

	let fh = ELF64_FileHeader*:elf_data;
	if !elf_verify_magic(fh) {
		print("ELF magic invalid\n");
		return null;
	}

	ELF64_SectHeader* strtab = elf_getsh(fh, fh.strtab_index);
	u8* strtab_start = elf_data + strtab.offs;

	u8[] interp = null[0..0];
	ELF64_Dyn* dyn = null;

	for usz i..fh.ph_count {
		let ph = elf_getph(fh, i);

		if ph.type == ELFPH_INTERP {
			interp = (elf_data + ph.offs)[0..ph.mem_size];
		}
		if ph.type == ELFPH_DYNAMIC {
			dyn = ELF64_Dyn*:elf_data + ph.offs;
		}

		print("PH ");
		print_i64(ph.type);
		print(" 0x");
		print_h64(ph.offs);
		print("\n");
	}

	u8* dynstr = null;

	while dyn && dyn.type != ELFDYN_NULL {
		if dyn.type == ELFDYN_STRTAB {
			dynstr = elf_data + dyn.val;
		}

		print("DYN ");
		print_i64(dyn.type);
		print(" 0x");
		print_h64(dyn.val);
		print("\n");
		dyn += sizeof(ELF64_Dyn);
	}

	ELF64_Sym[] dynsym = null[0..0];

	for usz i..fh.sh_count {
		let sh = elf_getsh(fh, i);
		u8* strtab_name = strtab_start + sh.name;
		u8[] name = strtab_name[0..cstrlen(strtab_name)];

		if sh.type == ELFSH_DYNSYM {
			dynsym = (ELF64_Sym*:elf_data + sh.offs)[0..sh.size/sizeof(ELF64_Sym)];
		}

		print("SH '");
		print(name);
		print("' offs:0x");
		print_h64(sh.offs);
		print(" type:");
		print_i64(sh.type);
		print("\n");
	}

	for usz i..dynsym.count {
		u8* strtab_name = dynstr + dynsym[i].name;
		u8[] name = strtab_name[0..cstrlen(strtab_name)];

		print("SYM ");
		print_i64(i);
		print(" '");
		print(name);
		print("'\n");
	}

	return fh;
}

let hton16 :: u16(u16 v) {
	return (v >> 8u) | ((v & 0xFF) << 8u);
}

let hton32 :: u32(u32 v) {
	return	((v & 0x000000FF) << 24u) |
			((v & 0x0000FF00) << 8u) |
			((v & 0x00FF0000) >> 8u) |
			((v & 0xFF000000) >> 24u);
}

// let hton64 :: u64(u64 v) {
// 	return	((v & 0x00000000000000FF) << 56u) |
// 			((v & 0x000000000000FF00) << 40u) |
// 			((v & 0x0000000000FF0000) << 24u) |
// 			((v & 0x00000000FF000000) << 8u) |
// 			((v & 0x000000FF00000000) >> 8u) |
// 			((v & 0x0000FF0000000000) >> 24u) |
// 			((v & 0x00FF000000000000) >> 40u) |
// 			((v & 0xFF00000000000000) >> 56u);
// }

let ipv4_addr_str :: u8(u8[] str, sockaddr_in_t* out) {
	u8[4] addr = { 0, 0, 0, 0 };
	usz j = 0;

	for usz i..usz:(str.count) {
		u8 c = str[i];
		if c == '.' {
			if ++j >= 4 {
				return 1;
			}
		}
		else {
			if is_digit(c) {
				addr[j] *= u8:10;
				addr[j] += c - '0';
			}
			else {
				return 1;
			}
		}
	}
	if j != 3 {
		return 1;
	}

	out.sin_addr = *u32*:addr.data;
	return 0;
}

let func :: u8() {
	print("ASDF\n");
	return 1;
}

let main :: u64() {
// 	u8[] libname = "/usr/lib/ld-linux-x86-64.so.2";
// 	u8[] libname = "/usr/lib/libvulkan.so.1";
// 	u8[] libname = "/usr/lib/libxcb.so";

// 	void* lib = dlopen(libname);
// 	if !lib {
// 		print("Failed to load '");
// 		print(libname);
// 		print("'\n");
// 		exit(1);
// 	}

	isz sock = socket(AF_INET, SOCK_STREAM, 0);
	if sock < 0 {
		print("socket creation failed\n");
	}

	sockaddr_in_t saddr;
	mset8(&saddr, 0, sizeof(sockaddr_in_t));
	saddr.sin_family = AF_INET;
	saddr.sin_port = hton16(80);

	if ipv4_addr_str("109.225.102.157", &saddr) {
		print("address string parsing failed\n");
	}
	else {
		print_h64(saddr.sin_addr);
		print("\n");
	}

	isz res = connect(sock, void*:&saddr, sizeof(sockaddr_in_t));
	if res < 0 {
		print("connection failed\n");
	}
	else {
		print("connection successful\n");
	}

	write(sock, "GET / HTTP/1.1\r\n\r\n");

	u8[512] buf;
	isz bytes;
	while bytes = read(sock, buf) {
		print(buf[0..bytes]);
	}

	exit(0);
}

