import "io.nyx", "elf.nyx";

let mcopy :: void(void* dst, void* src, usz bytes) {
	u8* dst_it = dst;
	u8* src_it = src;

	while bytes-- {
		*dst_it++ = *src_it++;
	}
}

let elf_verify_magic :: u8(ELF64_FileHeader* fh) {
	for usz i..fh.magic.count {
		if fh.magic[i] != ELFMAGIC[i] {
			return 0;
		}
	}
	return 1;
}

let elf_getsh :: ELF64_SectHeader*(ELF64_FileHeader* fh, usz i) {
	return ELF64_SectHeader*:(usz:fh + fh.sh_offs + fh.sh_size * i);
}

let elf_getph :: ELF64_ProgHeader*(ELF64_FileHeader* fh, usz i) {
	return ELF64_ProgHeader*:(usz:fh + fh.ph_offs + fh.ph_size * i);
}

let dlopen :: ELF64_FileHeader*(u8[] libname) {
	isz fd;
	if &fd->file_openr(libname) {
		return null;
	}

	stat_t st;
	fd->fstat(&st);

	u8* elf_data = malloc(st.st_size);
	fd->read(elf_data[0..st.st_size]);
	fd->close();

	let fh = ELF64_FileHeader*:elf_data;
	if !elf_verify_magic(fh) {
		print("ELF magic invalid\n");
	}

	ELF64_SectHeader* strtab = elf_getsh(fh, fh.strtab_index);
	u8* strtab_start = elf_data + u8*:strtab.offs;

	u8[] interp = null[0..0];
	ELF64_Dyn* dyn = null;

	for usz i..fh.ph_count {
		let ph = elf_getph(fh, i);

		if ph.type == ELFPH_INTERP {
			interp = (elf_data + u8*:ph.offs)[0..ph.mem_size];
		}
		if ph.type == ELFPH_DYNAMIC {
			dyn = ELF64_Dyn*:(usz:elf_data + ph.offs);
		}

		print("PH ");
		print_i64(ph.type);
		print(" 0x");
		print_h64(ph.offs);
		print("\n");
		dyn += void*:16;
	}

	u8* dynstr = null;

	while dyn && dyn.type != ELFDYN_NULL {
		if dyn.type == ELFDYN_STRTAB {
			dynstr = elf_data + void*:dyn.val;
		}

		print("DYN ");
		print_i64(dyn.type);
		print(" 0x");
		print_h64(dyn.val);
		print("\n");
		dyn += void*:16;
	}

	ELF64_Sym[] dynsym = null[0..0];

	for usz i..fh.sh_count {
		let sh = elf_getsh(fh, i);
		u8* strtab_name = strtab_start + u8*:sh.name;
		u8[] name = strtab_name[0..cstrlen(strtab_name)];

		if sh.type == ELFSH_DYNSYM {
			dynsym = (ELF64_Sym*:elf_data + ELF64_Sym*:sh.offs)[0..sh.size/24];
		}

		print("SH '");
		print(name);
		print("' offs:0x");
		print_h64(sh.offs);
		print(" type:");
		print_i64(sh.type);
		print("\n");
	}

	for usz i..dynsym.count {
		u8* strtab_name = dynstr + u8*:dynsym[i].name;
		u8[] name = strtab_name[0..cstrlen(strtab_name)];

		print("SYM ");
		print_i64(i);
		print(" '");
		print(name);
		print("'\n");
	}

	return fh;
}

let main :: u64() {
// 	u8[] libname = "/usr/lib/ld-linux-x86-64.so.2";
// 	u8[] libname = "/usr/lib/libvulkan.so.1";
	u8[] libname = "/usr/lib/libxcb.so";

	void* lib = dlopen(libname);
	if !lib {
		print("Failed to load '");
		print(libname);
		print("'\n");
		exit(1);
	}

	exit(0);
}

