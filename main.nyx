import "std/io.nyx", "std/mem.nyx", "std/hashtab.nyx", "lex.nyx", "parse.nyx";

let main :: u64() {
	Arena* arena = amcreate(null, 64M, 0);
	Allocator* alc = &arena.interf;

	u8[] in_path = "main.nyx";

	isz in_f;
	if fopenr(&in_f, in_path) {
		print("Failed to open '");
		print(in_path);
		print("'\n");
		goto err0;
	}

	stat_t st;
	if fstat(in_f, &st) < 0 {
		print("fstat() failed\n");
		goto err1;
	}

	u8* in_data = amalloc(arena, st.st_size + 2);
	in_data[0] = 0;
	in_data[st.st_size] = 0;
	u8[] invw = (in_data + 1)[0..st.st_size];
	if fread(in_f, invw) != st.st_size {
		print("read() failed\n");
		goto err1;
	}
	fclose(in_f);

	LexCtx lcx;
	mset8(&lcx, 0, sizeof(LexCtx));
	lcx.alc = alc;
	lcx.src = invw;
	if lex(&lcx) {
		print("Error: ");
		print(lcx.err_str);
		print("\n");
	}

	for usz i..lcx.out.count {
		Token* tk = &lcx.out[i];

		print(tk_info[tk.type].name_str);
		print(" '");
		print(tk.str);
		print("'\n");
	}

	ParseCtx pcx;
	mset8(&pcx, 0, sizeof(ParseCtx));
	pcx.alc = alc;
	pcx.lcx = &lcx;

	amdestroy(arena);
	exit(0);

err1:	fclose(in_f);
err0:	amdestroy(arena);
		exit(1);
}

