import "io.nyx", "elf.nyx", "dns.nyx";


let hton16 :: u16(u16 v) {
	return (v >> 8u) | ((v & 0xFF) << 8u);
}

let hton32 :: u32(u32 v) {
	return	((v & 0x000000FF) << 24u) |
			((v & 0x0000FF00) << 8u) |
			((v & 0x00FF0000) >> 8u) |
			((v & 0xFF000000) >> 24u);
}

// let hton64 :: u64(u64 v) {
// 	return	((v & 0x00000000000000FF) << 56u) |
// 			((v & 0x000000000000FF00) << 40u) |
// 			((v & 0x0000000000FF0000) << 24u) |
// 			((v & 0x00000000FF000000) << 8u) |
// 			((v & 0x000000FF00000000) >> 8u) |
// 			((v & 0x0000FF0000000000) >> 24u) |
// 			((v & 0x00FF000000000000) >> 40u) |
// 			((v & 0xFF00000000000000) >> 56u);
// }

let ipv4_parse_addr :: u8(u8[] str, sockaddr_in_t* out) {
	u8[][5] nums;
	usz j = 0;

	u8* num_start = str.data;
	for usz i..str.count {
		u8 c = str[i];
		if c == '.' {
			if j >= 3u {
				return 1;
			}
			nums[j++] = num_start[0..usz:(i - (num_start - str.data))];
			num_start = str.data + i + 1;
		}
		if c == ':' {
			if j != 3u {
				return 1;
			}
			nums[j++] = num_start[0..usz:(i - (num_start - str.data))];
			num_start = str.data + i + 1;
		}
	}
	if j < 3u {
		return 1;
	}
	nums[j] = num_start[0..usz:(str.count - (num_start - str.data))];

	u32 addr = 0;
	for usz i..4 {
		u64 v;
		if stou(nums[i], &v) || v > 0xFF {
			return 1;
		}
		addr |= v << i * 8;
	}

	if j == 4u {
		u64 v;
		if stou(nums[4], &v) || v > 0xFFFF {
			return 1;
		}
		out.sin_port = hton16(v);
	}

	out.sin_addr = addr;
	return 0;
}

let recv :: isz(isz sock, void[] buf) {
	void* it = buf.data, end = it + buf.count;
	while it < end {
		isz res = sock->read(it[0..usz:(end - it)]);
		if res <= 0 {
			return res;
		}

		it += res;
	}
	return buf.count;
}

let dns_encode_name :: isz(u8[] domain, u8[] out) {
	u8* q_it = out.data, q_max = q_it + out.count;
	u8* substr = domain.data;
	for usz i..domain.count {
		if domain[i] == '.' {
			usz substr_len = i - usz:(substr - domain.data);
			u8* q_it_next = q_it + substr_len + 1;
			if !substr_len || substr_len > 63u || q_it_next >= q_max {
				return -1;
			}
			*q_it++ = substr_len;
			for usz j..substr_len {
				*q_it++ = substr[j];
			}

			q_it = q_it_next;
			substr = domain.data + i + 1;
		}
	}

	usz substr_len = domain.count - usz:(substr - domain.data);
	u8* q_it_next = q_it + substr_len + 2;
	if !substr_len || substr_len > 63u || q_it_next >= q_max {
		return -1;
	}
	*q_it++ = substr_len;
	for usz j..substr_len {
		*q_it++ = substr[j];
	}

	*q_it++ = 0;
	return usz:(q_it - out.data);
}

let ipv4_dnslookup :: u8(u8[] dns_host, u8[] domain, sockaddr_in_t* out) {
	sockaddr_in_t saddr;
	mset8(&saddr, 0, sizeof(sockaddr_in_t));
	saddr.sin_family = AF_INET;
	saddr.sin_port = hton16(53);

	if ipv4_parse_addr(dns_host, &saddr) {
		return 1;
	}

	isz sock = socket(AF_INET, SOCK_STREAM, 0);
	if sock < 0 {
		return 1;
	}

	if sock->connect(void*:&saddr, sizeof(sockaddr_in_t)) < 0 {
		sock->close();
		return 1;
	}

	DNS_Header dh;
	mset8(&dh, 0, sizeof(DNS_Header));
	dh.flags = hton16(DNSH_QUERY | DNSH_STANDARD | DNSH_RD);
	dh.qdcount = hton16(1);

	DNS_Question dq;
	dq.qtype = hton16(DNST_A);
	dq.qclass = hton16(DNSC_IN);

	u8[256] question;
	isz qlen = dns_encode_name(domain, question);
	if qlen < 0 {
		sock->close();
		return 1;
	}

	u16 msglen = hton16(sizeof(DNS_Header) + qlen + sizeof(DNS_Question));
	sock->write((&msglen)[0..1]);
	sock->write((&dh)[0..1]);
	sock->write(question[0..qlen]);
	sock->write((&dq)[0..1]);

	// Receive message length
	if sock->recv((&msglen)[0..1]) <= 0 {
		sock->close();
		return 1;
	}
	msglen = hton16(msglen);

	// Receive message body
	u8[4096] buf;
	if sock->recv(buf[0..msglen]) <= 0 || msglen < u32:sizeof(DNS_Header) {
		sock->close();
		return 1;
	}

	sock->close();

	DNS_Header* rh = void*:buf.data;
	rh.flags = hton16(rh.flags);
	rh.qdcount = hton16(rh.qdcount);
	rh.ancount = hton16(rh.ancount);
	rh.nscount = hton16(rh.nscount);
	rh.arcount = hton16(rh.arcount);

	u16 rcode = rh.flags & DNSH_RCODE_MASK;
	if rcode != DNSH_NO_ERROR {
		return 1;
	}

	void* section_start = buf.data + sizeof(DNS_Header);
	u8* it = section_start;

	// TODO: Prevent out-of-bounds writes

	for usz i..rh.qdcount {
		while *it { it++; } // QNAME
		it += sizeof(DNS_Question);
	}

	for usz i..rh.ancount {
		while *it { it++; } // NAME
		let rr = DNS_RsrcRecord*:it;
		rr.type = hton16(rr.type);
		rr.class = hton16(rr.class);
		rr.ttl = hton16(rr.ttl);
		rr.rdlen = hton16(rr.rdlen);

		it += sizeof(DNS_RsrcRecord);

		if rr.type == DNST_A && rr.class == DNSC_IN {
			out.sin_addr = *u32*:it;
			return 0;
		}

		it += rr.rdlen; // RDATA
	}

	return 1;
}

let elf_verify_magic :: u8(ELF64_FileHeader* fh) {
	for usz i..fh.magic.count {
		if fh.magic[i] != ELFMAGIC[i] {
			return 0;
		}
	}
	return 1;
}

let elf_getsh :: ELF64_SectHeader*(ELF64_FileHeader* fh, usz i) {
	return ELF64_SectHeader*:(usz:fh + fh.sh_offs + fh.sh_size * i);
}

let elf_getph :: ELF64_ProgHeader*(ELF64_FileHeader* fh, usz i) {
	return ELF64_ProgHeader*:(usz:fh + fh.ph_offs + fh.ph_size * i);
}

let elf_getstr :: u8[](u8* strtab, usz offs) {
	u8* str = strtab + offs;
	return str[0..cstrlen(str)];
}

def DynLibrary :: struct {
	u8* data;
	ELF64_FileHeader* fh;
	u8* strtab;
	u8* strtab_dyn;
	ELF64_Sym[] syms;
}

let dlopen :: u8(u8[] libname, DynLibrary* out) {
	isz fd;
	if &fd->file_openr(libname) {
		print("Failed to open file\n");
		return 1;
	}

	stat_t st;
	fd->fstat(&st);

	u8* elf_data = malloc(st.st_size);
	fd->read(elf_data[0..st.st_size]);
	fd->close();

	let fh = ELF64_FileHeader*:elf_data;
	if !elf_verify_magic(fh) {
		print("ELF magic invalid\n");
		return 1;
	}

	ELF64_SectHeader* strtab = elf_getsh(fh, fh.strtab_index);
	u8* strtab_start = elf_data + strtab.offs;

	ELF64_SectHeader* got = null;

	ELF64_Sym[] dynsym = null[0..0];

	for usz i..fh.sh_count {
		let sh = elf_getsh(fh, i);
		u8[] name = elf_getstr(strtab_start, sh.name);

		if sh.type == ELFSH_DYNSYM {
			dynsym = (ELF64_Sym*:elf_data + sh.offs)[0..sh.size/sizeof(ELF64_Sym)];
		}
		if sh.type == ELFSH_PROGBITS && streq(name, ".got") {
			got = sh;
		}
	}

	if !got {
		print("Failed to find GOT\n");
		mfree(elf_data);
		return 1;
	}

	print("GOT: 0x");
	print_h64(got.offs);
	print("\n");

	u8[] interp = null[0..0];
	ELF64_Dyn* dyn = null;

	for usz i..fh.ph_count {
		let ph = elf_getph(fh, i);

		if ph.type == ELFPH_INTERP {
			interp = (elf_data + ph.offs)[0..ph.mem_size];
		}
		if ph.type == ELFPH_DYNAMIC {
			dyn = ELF64_Dyn*:elf_data + ph.offs;
		}
	}

	if !dyn {
		print("No dynamic section found\n");
		mfree(elf_data);
		return 1;
	}

	u8* dynstr = null;
	ELF64_RelAdd* rela_ptr = null;
	usz relasz = 0, relaent = 0;

	while dyn && dyn.type != ELFDYN_NULL {
		if dyn.type == ELFDYN_STRTAB {
			dynstr = elf_data + dyn.val;
		}
		if dyn.type == ELFDYN_RELA {
			rela_ptr = ELF64_RelAdd*:(elf_data + dyn.val);
		}
		if dyn.type == ELFDYN_RELASZ {
			relasz = dyn.val;
		}
		if dyn.type == ELFDYN_RELAENT {
			relaent = dyn.val;
		}

		print("DYN ");
		print_i64(dyn.type);
		print(" 0x");
		print_h64(dyn.val);
		print("\n");
		dyn += sizeof(ELF64_Dyn);
	}

	ELF64_RelAdd* rela = rela_ptr;
	usz rela_count = relasz / relaent;
	for usz i..rela_count {
		print("RELA 0x");
		print_h64(rela.offs);
		print(" ");

		u32 reltype = rela.info & ELFREL64_TYPE_MASK;
		u8 unkn = 1;

		if reltype == ELFREL_X64_REL32 {
			unkn = 0;
			print("REL32");
		}
		if reltype == ELFREL_X64_64 {
			unkn = 0;
			print("64");
		}
		if reltype == ELFREL_X64_TPOFF64 {
			unkn = 0;
			print("TPOFF64");
		}
		if reltype == ELFREL_X64_GLOB_DAT {
			unkn = 0;
			print("GLOB_DAT");
		}
		if reltype == ELFREL_X64_IREL32 {
			unkn = 0;
			print("IREL32");
		}

		if unkn {
			print("UNKN");
			print_i64(reltype);
		}
		print(" '");

		u32 sym = rela.info >> ELFREL64_SYM_SHIFT;
		print(elf_getstr(dynstr, dynsym[sym].name));
		print("' ");

		print_i64(rela.addend);
		print("\n");

		rela += relaent;
	}

	for usz i..dynsym.count {
// 		print("SYM ");
// 		print_i64(i);
// 		print(" '");
// 		print(elf_getstr(dynstr, dynsym[i].name));
// 		print("'\n");
	}

	out.data = elf_data;
	out.fh = fh;
	out.syms = dynsym;
	out.strtab = strtab_start;
	out.strtab_dyn = dynstr;
	return 0;
}

let dlsym :: void*(DynLibrary* lib, u8[] name) {
	for usz i..lib.syms.count {
		if streq(name, elf_getstr(lib.strtab_dyn, lib.syms[i].name)) {
			return lib.data + lib.syms[i].val;
		}
	}
	return null;
}

let main :: u64() {
// 	u8[] libname = "/usr/lib/ld-linux-x86-64.so.2";
	u8[] libname = "/usr/lib/libc.so.6";
// 	u8[] libname = "/usr/lib/libdl.so.2";

	DynLibrary lib;
	if dlopen(libname, &lib) {
		print("failed to load library\n");
	}

	let strlen_hnd = usz(u8*): dlsym(&lib, "strlen");
	if !strlen_hnd {
		print("Failed to load symbol\n");
	}

	strlen_hnd("ASDF\x00".data);

	exit(69);

	isz sock = socket(AF_INET, SOCK_STREAM, 0);
	if sock < 0 {
		print("socket creation failed\n");
	}

	sockaddr_in_t saddr;
	mset8(&saddr, 0, sizeof(sockaddr_in_t));
	saddr.sin_family = AF_INET;
	saddr.sin_port = hton16(80);

	if ipv4_dnslookup("9.9.9.9", "lutfisk.net", &saddr) {
		print("failed to resolve host\n");
	}

	if connect(sock, void*:&saddr, sizeof(sockaddr_in_t)) < 0 {
		print("connection failed\n");
	}

	write(sock, "GET / HTTP/1.1\r\nHost: lutfisk.net\r\nAccept: */*\r\nUpgrade-Insecure-Requests: 0\r\nConnection: close\r\n\r\n");

	u8[512] buf;
	isz bytes;
	while bytes = read(sock, buf) {
		print(buf[0..bytes]);
	}

	exit(0);
}

