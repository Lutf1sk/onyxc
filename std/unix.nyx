SYS :: enum usz {
	READ			: 0,
	WRITE			: 1,
	OPEN			: 2,
	CLOSE			: 3,
	STAT			: 4,
	FSTAT			: 5,
	LSTAT			: 6,
	MMAP			: 9,
	MPROTECT		: 10,
	MUNMAP			: 11,
	BRK				: 12,
	SOCKET			: 41,
	CONNECT			: 42,
	ACCEPT			: 43,
	SENDTO			: 44,
	RECVFROM		: 45,
	BIND			: 49,
	LISTEN			: 50,
	SETSOCKOPT		: 54,
	GETSOCKOPT		: 55,
	EXIT			: 60,
	TIME			: 201,
	CLOCK_GETTIME	: 228,
};
// ----- File I/O

PATH_MAX :: 4096;
FILE_MAX :: 256;

O_RDONLY	:: 0x00;
O_WRONLY	:: 0x01;
O_RDWR		:: 0x02;
O_CREAT		:: 0x40;
O_TRUNC		:: 0x200;
O_APPEND	:: 0x400;

S_IRUSR 	:: 0x100;
S_IWUSR 	:: 0x80;
S_IXUSR 	:: 0x40;

read :: isz(isz fd, void[] data) {
	return syscall(SYS.READ, fd, data.data, data.count);
};

write :: isz(isz fd, void[] data) {
	return syscall(SYS.WRITE, fd, data.data, data.count);
};

open :: isz(u8* path, i32 flags, i32 mode) {
	return syscall(SYS.OPEN, path, flags, mode);
};

close :: isz(isz fd) {
	return syscall(SYS.CLOSE, fd);
};

stat_t :: struct {
	u64 st_dev;
	u64 st_ino;
	u64 st_nlink;

	u32 st_mode;
	u32 st_uid;
	u32 st_gid;
	u32 pad;
	u64 st_rdev;
	i64 st_size;
	i64 st_blksize;
	i64 st_blocks;

	u64 st_atime;
	u64 st_atime_nsec;
	u64 st_mtime;
	u64 st_mtime_nsec;
	u64 st_ctime;
	u64 st_ctime_nsec;
	i64[3] unused;
};

stat :: isz(u8* path, stat_t* buf) {
	syscall(SYS.STAT, path, buf);
};

fstat :: isz(isz fd, stat_t* buf) {
	syscall(SYS.FSTAT, fd, buf);
};

lstat :: isz(u8* path, stat_t* buf) {
	syscall(SYS.LSTAT, path, buf);
};

// ----- Memory Allocation

MAP :: enum usz {
	SHARED			: 0x01,
	PRIVATE			: 0x02,
	SHARED_VALIDATE	: 0x03,
	FIXED			: 0x10,
	ANONYMOUS		: 0x20,

	POPULATE		: 0x008000,
	NONBLOCK		: 0x010000,
	STACK			: 0x020000,
	HUGETLB			: 0x040000,
	SYNC			: 0x080000,
	FIXED_NOREPLACE	: 0x100000,
	UNINITIALIZED	: 0x400000,
};

PROT :: enum usz {
	READ	: 0x01,
	WRITE	: 0x02,
	EXEC	: 0x04,
	SEM		: 0x08,
};

mmap :: void*(usz addr, usz size, PROT prot, MAP flags, usz fd, usz off) {
	return void*:syscall(SYS.MMAP, addr, size, prot, flags, fd, off);
};

mprotect :: i64(usz addr, usz size, usz prot) {
	return syscall(SYS.MPROTECT, addr, size, prot);
};

munmap :: void*(usz addr, usz size) {
	return void*:syscall(SYS.MUNMAP, addr, size);
};

// ----- Time

CLOCK :: enum usz {
	REALTIME				: 0,
	MONOTONIC				: 1,
	PROCESS_CPUTIME_ID	: 2,
	THREAD_CPUTIME_ID		: 3,
};

timespec_t :: struct {
	u64 tv_sec;
	u64 tv_nsec;
};

clock_gettime :: isz(CLOCK clockid, timespec_t* ts) {
	return syscall(SYS.CLOCK_GETTIME, clockid, ts);
};

// ----- Sockets

PF :: enum u16 {
	UNSPEC	: 0,
	LOCAL	: 1,
	INET	: 2,
	INET6	: 10,
};

AF :: enum u16 {
	UNSPEC	: PF.UNSPEC,
	LOCAL	: PF.LOCAL,
	INET	: PF.INET,
	INET6	: PF.INET6,
};

SOCK :: enum u32 {
	STREAM		: 1,
	DGRAM		: 2,
	RAW			: 3,
	CLOEXEC		: 0x00080000,
	NONBLOCK	: 0x00000800,
};

SO :: enum u32 {
	DEBUG		: 1,	// i32
	REUSEADDR	: 2,	// i32
	DONTROUTE	: 5,	// i32
	BROADCAST	: 6,	// i32
	SNDBUF		: 7,	// i32
	RCVBUF		: 8,	// i32
	KEEPALIVE	: 9,	// i32
	OOBLINE		: 10,	// i32
	LINGER		: 13,	// i32
	RCVLOWAT		: 18,	// i32
	SNDLOWAT		: 19,	// i32
	RCVTIMEO		: 20,	// timeval_t
	SNDTIMEO		: 21,	// timeval_t
};

sockaddr_t :: struct {
	u16 sa_family;
	u8[14] sa_data;
};

sockaddr_in_t :: struct {
	u16 sin_family;
	u16 sin_port;	// Big-endian
	u32 sin_addr;	// Big-endian
	u8[8] pad;
};

sockaddr_in6_t :: struct {
	u16 sin6_family;
	u16 sin6_port;		// Big-endian
	u32 sin6_flowinfo;	// Big-endian
	u8[16] sin6_addr;
	u32 sin6_scope_id;
};

socket :: isz(AF family, SOCK type, PF protocol) {
	return syscall(SYS.SOCKET, family, type, protocol);
};

connect :: isz(isz fd, sockaddr_t* addr, i32 addrlen) {
	return syscall(SYS.CONNECT, fd, addr, addrlen);
};

accept :: isz(isz fd, sockaddr_t* addr_out, i32 addrlen) {
	return syscall(SYS.ACCEPT, fd, addr_out, addrlen);
};

sendto :: isz(isz fd, void* buf, usz len, u32 flags, sockaddr_t* addr, i32 addrlen) {
	return syscall(SYS.SENDTO, fd, buf, len, flags, addr, addrlen);
};

recvfrom :: isz(isz fd, void* buf, usz len, u32 flags, sockaddr_t* addr, i32 addrlen) {
	return syscall(SYS.RECVFROM, fd, buf, len, flags, addr, addrlen);
};

bind :: isz(isz fd, sockaddr_t* addr, i32 addrlen) {
	return syscall(SYS.BIND, fd, addr, addrlen);
};

listen :: isz(isz fd, i32 backlog) {
	return syscall(SYS.LISTEN, fd, backlog);
};

setsockopt :: isz(isz fd, i32 level, SO optname, void* optval, i32 optlen) {
	return syscall(SYS.SETSOCKOPT, fd, level, optname, optval, optlen);
};

getsockopt :: isz(isz fd, i32 level, SO optname, void* optval, i32* optlen) {
	return syscall(SYS.GETSOCKOPT, fd, level, optname, optval, optlen);
};

// ----- Misc.

exit :: void(i32 code) {
	syscall(SYS.EXIT, code);
};

