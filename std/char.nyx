
def CTYPE :: enum u8 {
	NONE	:: 0x00,
	ALPHA	:: 0x01,
	DIGIT	:: 0x02,
	SPACE	:: 0x04,
};

CTYPE[256] ctype_tab :: {
	CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE,			// 0..7
	CTYPE.NONE, CTYPE.SPACE, CTYPE.SPACE, CTYPE.SPACE, CTYPE.NONE, CTYPE.SPACE, CTYPE.NONE, CTYPE.NONE,		// 8..15
	CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE,			// 16..23
	CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE,			// 24..31

	CTYPE.SPACE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE,		// 32..39
	CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE,			// 40..47
	CTYPE.DIGIT, CTYPE.DIGIT, CTYPE.DIGIT, CTYPE.DIGIT, CTYPE.DIGIT, CTYPE.DIGIT, CTYPE.DIGIT, CTYPE.DIGIT,	// 48..55
	CTYPE.DIGIT, CTYPE.DIGIT, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE,		// 56..63

	CTYPE.NONE, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA,	// 64..71
	CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA,	// 72..79
	CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA,	// 80..87
	CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE,		// 88..95

	CTYPE.NONE, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA,	// 96..103
	CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA,	// 104..111
	CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA,	// 112..119
	CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.ALPHA, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE, CTYPE.NONE,		// 120..127
};

let is_alpha8 :: u8(u8 c) {
	return ctype_tab[c] & CTYPE.ALPHA;
}

let is_alpha32 :: u8(u32 c) {
	return c < ctype_tab.count && ctype_tab[c] & CTYPE.ALPHA;
}

let is_digit8 :: u8(u8 c) {
	return ctype_tab[c] & CTYPE.DIGIT;
}

let is_digit32 :: u8(u32 c) {
	return c < ctype_tab.count && ctype_tab[c] & CTYPE.DIGIT;
}

let is_space8 :: u8(u8 c) {
	return ctype_tab[c] & CTYPE.SPACE;
}

let is_space32 :: u8(u32 c) {
	return c < ctype_tab.count && ctype_tab[c] & CTYPE.SPACE;
}

