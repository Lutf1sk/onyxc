
let print :: i32 (u8[] str) {
	return syscall(1, 1, str.data, str.count);
}

let write :: i64(i64 fd, u8[] data) {
	return syscall(1, fd, data.data, data.count);
}

let open :: i64(u8* path, u64 flags, u64 mode) {
	return syscall(2, path, flags, mode);
}

let read :: i64(i64 fd, u8[] data) {
	return syscall(0, fd, data.data, data.count);
}

let close :: i64(i64 fd) {
	return syscall(3, fd);
}

u64 O_RDONLY :: 0,
	O_WRONLY :: 1,
	O_RDWR :: 2,
	O_CREAT :: 64,
	O_TRUNC :: 512,
	O_APPEND :: 1024,

	S_IRUSR :: 256,
	S_IWUSR :: 128,
	S_IXUSR :: 64;

let print_i64 :: i64(i64 n) {
	u8[32] str;
	u8* end = str.data + u8*:(str.count), it = end - u8*: 1;

	while n >= 10 {
		*it-- = n % 10 + '0';
		n /= 10;
	}
	*it-- = n + '0';

	u8[] num;
	num.data = it;
	num.count = u64:(end - it);
	print(num);
	return num.count;
}

let print_h64 :: i64(i64 n) {
	u8[16] hex_conv_tab = {
		'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
	};

	u8[32] str;
	u8* end = str.data + u8*:(str.count), it = end - u8*: 1;

	while n >= 16 {
		*it-- = hex_conv_tab[n & 0xF];
		n >>= 4;
	}
	*it-- = hex_conv_tab[n];

	u8[] num;
	num.data = it;
	num.count = u64:(end - it);
	print(num);
	return num.count;
}

let main :: i32() {

	for i32 i..256 {
		print("0x");
		print_h64(i);
		print("\n");
	}

	return 1;
}

