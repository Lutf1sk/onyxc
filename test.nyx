def AllocateCB	:: void*(void* usr, u64 size),
	FreeCB		:: void(void* usr, void* ptr),
	ReallocCB	:: void*(void* usr, void* ptr, u64 size);

def Allocator :: struct {
	AllocateCB alloc;
	ReallocCB realloc;
	FreeCB free;
}

let read :: i64(i64 fd, u8[] data) {
	return syscall(0, fd, data.data, data.count);
}

let write :: i64(i64 fd, u8[] data) {
	return syscall(1, fd, data.data, data.count);
}

let open :: i64(u8* path, u64 flags, u64 mode) {
	return syscall(2, path, flags, mode);
}

let close :: i64(i64 fd) {
	return syscall(3, fd);
}

let print :: i64(u8[] str) {
	return write(1, str);
}

u64 O_RDONLY	:: 0x00,
	O_WRONLY	:: 0x01,
	O_RDWR		:: 0x02,
	O_CREAT		:: 0x40,
	O_TRUNC		:: 0x200,
	O_APPEND	:: 0x400,

	S_IRUSR 	:: 0x100,
	S_IWUSR 	:: 0x80,
	S_IXUSR 	:: 0x40;

let print_i64 :: i64(i64 n) {
	if (n < 0) {
		print("-");
		n = -n;
	}

	u8[32] str;
	u8* end = str.data + u8*:(str.count), it = end - u8*:1;

	while n >= 10 {
		*it-- = n % 10 + '0';
		n /= 10;
	}
	*it = n + '0';

	u8[] view;
	view.data = it;
	view.count = u64:(end - it);
	print(view);
	return view.count;
}

// u8[16] hex_conv_tab = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };

u8[16] ctab :: "0123456789ABCDEF";

u8[16] hex_conv_tab :: "0123456789ABCDEF";

let print_h64 :: i64(u64 n) {
// 	u8[16] hex_conv_tab :: ctab;

	u8[32] str;
	u8* end = str.data + u8*:(str.count), it = end - u8*:1;

	while n > 0x0F {
		*it-- = hex_conv_tab[n & 0x0F];
		n >>= 4;
	}
	*it = hex_conv_tab[n];

	u8[] view;
	view.data = it;
	view.count = u64:(end - it);
	print(view);
	return view.count;
}

let main :: u64() {
	i64 fd = open("test\x00".data, 0, 0);

	for u32 i..0x10 {
		print_i64(i);
		print(": 0x");
		print_h64(i);
		print("\n");
	}

	return 0;
}


